## Методы функционального программирования  

**Функциональное программирование** - это стиль программирования, использующий композиции функций.  
В императивном программировании мы используем последовательность команд и переменные для промежуточного сохранения результатов, в функциональном промежуточные результаты сразу передаются на следующий этап обработки.

---  

Основные особенности функциональных программ:  
* функция есть объект и её можно передавать через переменную в качестве аргумента в другую функцию  
* функция должна возвращать значения  
* вычисление - есть композиция функций  
* прежде всего эти программы для обработки коллекций  
* отказ от использования традиционных структурных операторов  
* неизменяемость входных потоков данных  
* отсутсвие присваивания промежуточных результатов  
* рекурсивная обработка данных  

--- 
Что изучим:
> генераторы и итераторы  
> ленивые вычисления  
> def  
> lambda  
> map  
> filter  
> reduce  
> zip  
> split  
> join  
> enumerate  

Способы определения функций (def, lambda)  

Порядок аргументов внутри функции:  
- позиционные аргументы  
- *args  
- аргументы с ключевыми словами  
- **kwargs  

```
def example1(arg1, arg2, *args, **kwargs):
	...
	
def example2(arg1, arg2, *args, kw1="human", kw2="ork", **kwargs):
	...
```

---  

```
s = '1234567890'
lst = list(s)

# map
print(lst)
acc = 0
for item in lst:
    acc += int(item)
print(acc)

lst = list(map(lambda x: int(x), lst))
print(lst)
print(sum(lst))

lst = list(map(int, lst))
print(lst)
print(sum(lst))

# 1 2 3 88 10
print(sum(list(map(int, input().split()))))

# filter
# сумма всех отрицательных
print(sum(filter(lambda x: x < 0 , map(int, input().split()))))

# reduce
from functools import reduce

lst = [1, 2, 3, 4, 5, 6]
print(reduce(lambda acc, cur: acc + cur, lst, 100))
print(reduce(lambda acc, cur: acc + cur, lst))

```

---  

Вот так можно проверить продолжительность исполнения участка кода на Python 3:  

```
import time, os

start = time.monotonic()
time.sleep(2) # имитация измеряемой функции
finish = time.monotonic()

result = finish - start
print(result*1000, "миллисекунд")
```
